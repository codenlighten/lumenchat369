import { exec } from 'child_process';
import { promisify } from 'util';
import { createInterface } from 'readline';
import { logCommand } from './auditLogger.js';

const execPromise = promisify(exec);

/**
 * Terminal Executor - Executes commands generated by agents with safety gates
 * 
 * Features:
 * - Permission-based execution (auto-approve vs manual)
 * - Dry-run mode for testing
 * - Command sanitization and blacklisting
 * - Timeout protection
 * - Audit trail integration
 */

// Dangerous command patterns to block
const DANGEROUS_PATTERNS = [
  /rm\s+-rf\s+\/($|\s)/,  // rm -rf /
  /:\(\)\{.*:\|:.*\}/,     // Fork bombs
  /\/dev\/sda/,            // Direct disk writes
  /mkfs/,                  // Format commands
  /dd\s+if=/,              // dd operations
  /\/etc\/passwd/,         // Password file modification
  /curl.*\|.*bash/,        // Pipe to bash
  /wget.*\|.*sh/,          // Pipe to shell
];

/**
 * Executes terminal commands generated by agents
 * @param {object} agentResponse - Response from terminalAgent or baseAgentExtended
 * @param {string} agentResponse.command - The terminal command to execute
 * @param {string} agentResponse.commandReasoning - Why this command was chosen
 * @param {boolean} agentResponse.requiresApproval - Whether agent thinks approval is needed
 * @param {object} config - Execution configuration
 * @param {boolean} config.autoApprove - Skip manual approval (for CI/CD)
 * @param {boolean} config.dryRun - Don't actually execute, just validate
 * @param {string} config.cwd - Working directory (defaults to project root)
 * @param {number} config.timeout - Max execution time in ms
 * @param {object} config.policyReport - Safety policy evaluation report (optional)
 * @returns {Promise<object>} Execution result with status, stdout, stderr
 */
export async function executeAgentCommand(agentResponse, config = {}) {
  const {
    command,
    commandReasoning = 'No reasoning provided',
    reasoning = commandReasoning, // Handle both field names
    requiresApproval = true
  } = agentResponse;

  const {
    autoApprove = false,
    dryRun = false,
    cwd = process.cwd(),
    timeout = 30000,
    allowDangerous = false,
    policyReport = null // Safety policy report from policyEngine
  } = config;

  // Validate command exists
  if (!command || command.trim() === '') {
    const error = { status: 'error', message: 'No command provided for execution.' };
    await logCommand({ command: '', ...error, reasoning });
    return error;
  }

  const trimmedCommand = command.trim();

  console.log('\nü§ñ [Lumen Terminal Executor]');
  console.log(`üìù Reasoning: ${reasoning}`);
  console.log(`üíª Command: ${trimmedCommand}`);
  console.log(`üìÇ Working Directory: ${cwd}`);
  
  // Display policy report if provided
  if (policyReport) {
    console.log(`üõ°Ô∏è  Policy: ${policyReport.policy.name} (${policyReport.policy.environment})`);
    console.log(`   Security Level: ${policyReport.securityLevel}`);
    
    if (policyReport.reasoning.length > 0) {
      console.log(`   Security Thoughts:`);
      policyReport.reasoning.slice(0, 3).forEach(r => console.log(`     ‚Ä¢ ${r}`));
    }
    
    if (policyReport.warnings.length > 0) {
      console.log(`   ‚ö†Ô∏è  Warnings:`);
      policyReport.warnings.forEach(w => console.log(`     ‚Ä¢ ${w}`));
    }
  }

  // Safety check: Detect dangerous patterns (legacy check - policy engine is primary)
  if (!allowDangerous && !policyReport) {
    const dangerCheck = checkCommandSafety(trimmedCommand);
    if (!dangerCheck.safe) {
      const error = {
        status: 'blocked',
        message: `Command blocked for safety: ${dangerCheck.reason}`,
        command: trimmedCommand,
        reasoning
      };
      console.error(`üö´ ${error.message}`);
      await logCommand(error);
      return error;
    }
  }

  // Dry run mode
  if (dryRun) {
    console.log('üß™ [DRY RUN] Command would be executed but dryRun=true');
    const result = {
      status: 'dry-run',
      command: trimmedCommand,
      reasoning,
      message: 'Command validated but not executed (dry run mode)'
    };
    await logCommand(result);
    return result;
  }

  // Permission gate: autoApprove overrides requiresApproval
  const needsManualApproval = autoApprove ? false : (policyReport ? policyReport.requiresApproval : requiresApproval);

  if (needsManualApproval) {
    console.log('‚ö†Ô∏è  Manual approval required');
    
    // Show policy reasoning if available
    if (policyReport && policyReport.reasoning.length > 0) {
      console.log('   Policy says:');
      policyReport.reasoning.forEach(r => console.log(`     ${r}`));
    }
    
    const approved = await promptUserForApproval(trimmedCommand);
    
    if (!approved) {
      const result = {
        status: 'denied',
        message: 'Execution halted by user',
        command: trimmedCommand,
        reasoning,
        policyReport
      };
      console.log('‚ùå User denied execution');
      await logCommand(result);
      return result;
    }
    console.log('‚úÖ User approved execution');
  } else {
    const approvalReason = policyReport 
      ? `Policy auto-approved (${policyReport.securityLevel})`
      : 'Legacy auto-approve (autoApprove=true, requiresApproval=false)';
    console.log(`‚ö° ${approvalReason}`);
  }

  // Execute the command
  try {
    console.log('üöÄ Executing command...');
    const startTime = Date.now();
    
    const { stdout, stderr } = await execPromise(trimmedCommand, {
      cwd,
      timeout,
      shell: '/bin/sh'
    });

    const executionTime = Date.now() - startTime;

    const result = {
      status: 'success',
      command: trimmedCommand,
      reasoning,
      stdout: stdout.trim(),
      stderr: stderr.trim(),
      executionTimeMs: executionTime,
      cwd,
      policyReport: policyReport ? {
        securityLevel: policyReport.securityLevel,
        policy: policyReport.policy.name,
        warnings: policyReport.warnings
      } : null
    };

    console.log(`‚úÖ Command executed successfully (${executionTime}ms)`);
    if (stdout.trim()) {
      console.log('\nüì§ Output:');
      console.log(stdout.trim());
    }
    if (stderr.trim()) {
      console.log('\n‚ö†Ô∏è  Stderr:');
      console.log(stderr.trim());
    }

    await logCommand(result);
    return result;

  } catch (error) {
    const result = {
      status: 'error',
      command: trimmedCommand,
      reasoning,
      exitCode: error.code || -1,
      message: error.message,
      stderr: error.stderr?.trim() || '',
      stdout: error.stdout?.trim() || '',
      cwd
    };

    console.error(`‚ùå Execution failed: ${error.message}`);
    if (error.stderr) {
      console.error('Error output:', error.stderr.trim());
    }

    await logCommand(result);
    return result;
  }
}

/**
 * Check if a command contains dangerous patterns
 * @param {string} command - Command to check
 * @returns {object} Safety check result
 */
function checkCommandSafety(command) {
  for (const pattern of DANGEROUS_PATTERNS) {
    if (pattern.test(command)) {
      return {
        safe: false,
        reason: `Matches dangerous pattern: ${pattern.source}`
      };
    }
  }

  return { safe: true };
}

/**
 * Prompt user for command approval (CLI-based)
 * @param {string} command - Command requiring approval
 * @returns {Promise<boolean>} Whether user approved
 */
async function promptUserForApproval(command) {
  // In CI/automated environments, check for ENV var override
  if (process.env.LUMEN_AUTO_APPROVE === 'true') {
    return true;
  }

  const rl = createInterface({
    input: process.stdin,
    output: process.stdout
  });

  return new Promise((resolve) => {
    rl.question(`\n‚ùì Execute this command? (y/n): ${command}\n> `, (answer) => {
      rl.close();
      const normalized = answer.trim().toLowerCase();
      resolve(normalized === 'y' || normalized === 'yes');
    });
  });
}

/**
 * Execute multiple commands in sequence
 * @param {Array<object>} agentResponses - Array of command responses
 * @param {object} config - Execution configuration
 * @returns {Promise<Array<object>>} Array of execution results
 */
export async function executeCommandSequence(agentResponses, config = {}) {
  const results = [];
  
  console.log(`\nüîÑ Executing ${agentResponses.length} commands in sequence...`);
  
  for (const [index, response] of agentResponses.entries()) {
    console.log(`\n[${index + 1}/${agentResponses.length}]`);
    const result = await executeAgentCommand(response, config);
    results.push(result);
    
    // Stop on error unless continueOnError is set
    if (result.status === 'error' && !config.continueOnError) {
      console.log('‚ùå Stopping sequence due to error');
      break;
    }
    
    // Stop if user denies
    if (result.status === 'denied') {
      console.log('‚õî Stopping sequence due to user denial');
      break;
    }
  }
  
  return results;
}

/**
 * Alias for better naming consistency with orchestrator
 */
export const executeWithPermission = executeAgentCommand;

/**
 * Simple command executor wrapper for orchestrator
 * @param {string} command - Command to execute
 * @param {object} options - Options
 * @returns {Promise<object>} Result with output, exitCode, error
 */
export async function executeCommand(command, options = {}) {
  const agentResponse = {
    command: command,
    commandReasoning: options.reasoning || 'Orchestrator command execution',
    requiresApproval: options.requiresApproval || false
  };
  
  const result = await executeAgentCommand(agentResponse, {
    autoApprove: options.autoApprove !== undefined ? options.autoApprove : true,
    ...options
  });
  
  return {
    output: result.stdout || result.message || '',
    exitCode: result.exitCode || (result.status === 'success' ? 0 : 1),
    error: result.stderr || (result.status === 'error' ? result.message : null)
  };
}
